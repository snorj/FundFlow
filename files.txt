Here is finance/models.py:

from django.db import models
from django.conf import settings
from django.contrib.auth import get_user_model

User = get_user_model()

class PlaidItem(models.Model):
    """
    Represents a Plaid Item - an item is a connection to a financial institution
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='plaid_items')
    item_id = models.CharField(max_length=255, unique=True)
    access_token = models.CharField(max_length=255)
    institution_id = models.CharField(max_length=255, null=True, blank=True)
    institution_name = models.CharField(max_length=255, null=True, blank=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'plaid_items'

    def belongs_to_user(self, user):
        """Check if this item belongs to the given user"""
        return self.user_id == user.id
    
    def __str__(self):
        return f"Plaid Item: {self.institution_name or 'Unknown'} for {self.user.username}"

class Account(models.Model):
    """
    Represents a financial account from Plaid
    """
    ACCOUNT_TYPES = (
        ('depository', 'Depository'),
        ('credit', 'Credit'),
        ('loan', 'Loan'),
        ('investment', 'Investment'),
        ('other', 'Other'),
    )
    
    plaid_item = models.ForeignKey(PlaidItem, on_delete=models.CASCADE, related_name='accounts')
    account_id = models.CharField(max_length=255)
    name = models.CharField(max_length=255)
    official_name = models.CharField(max_length=255, null=True, blank=True)
    account_type = models.CharField(max_length=50, choices=ACCOUNT_TYPES)
    account_subtype = models.CharField(max_length=50, blank=True, null=True)
    current_balance = models.DecimalField(max_digits=12, decimal_places=2, null=True, blank=True)
    available_balance = models.DecimalField(max_digits=12, decimal_places=2, null=True, blank=True)
    mask = models.CharField(max_length=4, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'accounts'
        unique_together = [['plaid_item', 'account_id']]
    
    def __str__(self):
        return f"{self.name} ({self.mask or 'xxxx'})"
    
    def belongs_to_user(self, user):
        """Check if this account belongs to the given user"""
        return self.plaid_item.user_id == user.id

class Category(models.Model):
    """
    Represents a transaction category
    """
    name = models.CharField(max_length=255)
    plaid_category_id = models.CharField(max_length=255, null=True, blank=True)
    parent_category = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='subcategories')
    
    # For custom user categories
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, related_name='custom_categories')
    is_custom = models.BooleanField(default=False)
    
    # For budget tracking
    budget_amount = models.DecimalField(max_digits=12, decimal_places=2, null=True, blank=True)
    
    # System fields
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'categories'
        verbose_name_plural = 'categories'
        unique_together = [['name', 'user']]
    
    def __str__(self):
        return self.name

class Transaction(models.Model):
    """
    Represents a financial transaction from Plaid
    """
    account = models.ForeignKey(Account, on_delete=models.CASCADE, related_name='transactions')
    transaction_id = models.CharField(max_length=255, unique=True)
    
    # Basic transaction details
    date = models.DateField()
    name = models.CharField(max_length=255)
    amount = models.DecimalField(max_digits=12, decimal_places=2)
    
    # Category information
    category_string = models.CharField(max_length=255, null=True, blank=True)  # Original category string from Plaid
    category_id = models.CharField(max_length=255, null=True, blank=True)  # Original category ID from Plaid
    categories = models.ManyToManyField(Category, related_name='transactions', blank=True)  # Linked categories
    
    # Additional transaction data
    pending = models.BooleanField(default=False)
    payment_channel = models.CharField(max_length=50, null=True, blank=True)
    
    # Location data
    address = models.CharField(max_length=255, null=True, blank=True)
    city = models.CharField(max_length=100, null=True, blank=True)
    country = models.CharField(max_length=100, null=True, blank=True)
    postal_code = models.CharField(max_length=20, null=True, blank=True)
    region = models.CharField(max_length=100, null=True, blank=True)
    
    # Merchant data
    merchant_name = models.CharField(max_length=255, null=True, blank=True)
    
    # System fields
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'transactions'
        ordering = ['-date', '-created_at']
    
    def __str__(self):
        return f"{self.name} - ${self.amount} on {self.date}"


Here is finance/views.py:
from django.shortcuts import render
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from .services.plaid_service import PlaidService
from django.db import transaction as db_transaction
from .models import PlaidItem, Account, Transaction, Category
from .serializers import PlaidItemSerializer, AccountSerializer, TransactionSerializer, CategorySerializer
from rest_framework.pagination import PageNumberPagination
from django.db import models
from django.http import Http404
import logging
logger = logging.getLogger(__name__)

class LinkTokenView(APIView):
    """
    Create a link token for initializing Plaid Link
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        # Initialize the Plaid service
        plaid_service = PlaidService()
        
        # Create a link token for the user
        link_token = plaid_service.create_link_token(request.user.id)
        
        if link_token:
            return Response({'link_token': link_token}, status=status.HTTP_200_OK)
        else:
            return Response({'error': 'Failed to create link token'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class AccessTokenExchangeView(APIView):
    """
    Exchange a public token for an access token and save the Plaid item
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        logger.info(f"User {request.user.id} ({request.user.username}) is connecting an account")
        
        # Get the public token from the request
        public_token = request.data.get('public_token')
        institution_id = request.data.get('institution_id')
        institution_name = request.data.get('institution_name')
        
        logger.info(f"Institution: {institution_name} ({institution_id})")
        
        if not public_token:
            logger.warning("Missing public token in request")
            return Response({'error': 'Public token is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Initialize the Plaid service
        plaid_service = PlaidService()
        
        # Exchange the public token for an access token
        exchange_result = plaid_service.exchange_public_token(public_token)
        
        if not exchange_result:
            logger.error("Failed to exchange public token")
            return Response({'error': 'Failed to exchange public token'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        # Get the access token and item ID
        access_token = exchange_result['access_token']
        item_id = exchange_result['item_id']
        
        logger.info(f"Successfully exchanged public token for item_id: {item_id}")
        
        # Save the Plaid item
        plaid_item = PlaidItem.objects.create(
            user=request.user,
            item_id=item_id,
            access_token=access_token,
            institution_id=institution_id,
            institution_name=institution_name
        )
        
        logger.info(f"Created PlaidItem with ID: {plaid_item.id}")
        
        # Fetch accounts associated with this item
        accounts_data = plaid_service.get_accounts(access_token)
        
        if accounts_data:
            logger.info(f"Found {len(accounts_data)} accounts for item {item_id}")
            # Create Account objects for each account
            for account_data in accounts_data:
                Account.objects.create(
                    plaid_item=plaid_item,
                    account_id=account_data.account_id,
                    name=account_data.name,
                    official_name=account_data.official_name,
                    account_type=account_data.type,
                    account_subtype=account_data.subtype,
                    current_balance=account_data.balances.current if hasattr(account_data.balances, 'current') else None,
                    available_balance=account_data.balances.available if hasattr(account_data.balances, 'available') else None,
                    mask=account_data.mask
                )
        else:
            logger.warning(f"No accounts found for item {item_id}")
        
        # Log all PlaidItems after creation
        all_items = PlaidItem.objects.all()
        user_item_mapping = {}
        for item in all_items:
            if item.user_id not in user_item_mapping:
                user_item_mapping[item.user_id] = []
            user_item_mapping[item.user_id].append(f"{item.id}: {item.institution_name}")
        
        logger.info(f"Current PlaidItem distribution: {user_item_mapping}")

        # Return success response
        logger.info(f"Account connection completed successfully for user {request.user.id}")
        return Response({
            'success': True,
            'message': 'Account successfully connected',
            'institution_name': institution_name
        }, status=status.HTTP_201_CREATED)

class PlaidItemsView(APIView):
    """
    List all Plaid items for the authenticated user
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        plaid_items = PlaidItem.objects.filter(user=request.user)
        serializer = PlaidItemSerializer(plaid_items, many=True)
        return Response(serializer.data)

class AccountsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        logger.info(f"User {request.user.id} ({request.user.username}) is requesting accounts")
        
        # Use direct user_id comparison 
        accounts = Account.objects.filter(plaid_item__user_id=request.user.id)
        
        # Log each account being returned
        for account in accounts:
            logger.info(f"Returning account {account.id} ({account.name}) from item {account.plaid_item_id} to user {request.user.id}")
        
        logger.info(f"Found {accounts.count()} accounts for user {request.user.id}")
        
        serializer = AccountSerializer(accounts, many=True)
        return Response(serializer.data)
    
def dashboard_view(request):
    """
    Render the main dashboard view
    """
    return render(request, 'finance/dashboard.html', {
        'title': 'Dashboard',
    })

class TransactionFetchView(APIView):
    """
    Fetch and store transactions for a Plaid item
    """
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        logger.info(f"User {request.user.id} ({request.user.username}) is requesting transaction fetch")
        item_id = request.data.get('item_id')
        
        if not item_id:
            logger.warning("Missing item_id in request")
            return Response({'error': 'Item ID is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get the Plaid item - explicitly filter by the current user
            plaid_item = PlaidItem.objects.get(item_id=item_id, user=request.user)
            
            # Verify ownership (additional security check)
            if not plaid_item.user_id == request.user.id:
                logger.warning(f"User {request.user.id} attempted to access item {item_id} owned by user {plaid_item.user_id}")
                return Response(
                    {'error': 'You do not have permission to access this item'}, 
                    status=status.HTTP_403_FORBIDDEN
                )
            
            logger.info(f"Fetching transactions for item {item_id} (institution: {plaid_item.institution_name})")
            
            # Initialize the Plaid service
            plaid_service = PlaidService()
            
            # Get transactions for the last 30 days by default
            processed_data = plaid_service.process_transactions(
                plaid_item.access_token,
                item_id=item_id
            )
            
            if not processed_data:
                logger.error(f"Failed to fetch transactions for item {item_id}")
                return Response(
                    {'error': 'Failed to fetch transactions'}, 
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
            
            # Update account balances
            with db_transaction.atomic():
                # Store the transactions
                transactions_created = 0
                
                for transaction_data in processed_data['transactions']:
                    account_id = transaction_data.pop('account_id')
                    
                    try:
                        # Get the account - ensure it belongs to this plaid_item
                        account = Account.objects.get(account_id=account_id, plaid_item=plaid_item)
                        
                        # Check if transaction already exists
                        transaction_id = transaction_data['transaction_id']
                        transaction, created = Transaction.objects.update_or_create(
                            transaction_id=transaction_id,
                            defaults={
                                'account': account,
                                **transaction_data
                            }
                        )
                        
                        if created:
                            transactions_created += 1
                    
                    except Account.DoesNotExist:
                        # Log this error but continue processing other transactions
                        logger.warning(f"Account with ID {account_id} not found for item {item_id}")
                
                # Update account balances
                for account_id, account_data in processed_data['accounts'].items():
                    try:
                        account = Account.objects.get(account_id=account_id, plaid_item=plaid_item)
                        account.current_balance = account_data['balances']['current']
                        account.available_balance = account_data['balances']['available']
                        account.save()
                    except Account.DoesNotExist:
                        # Log this error but continue processing other accounts
                        logger.warning(f"Account with ID {account_id} not found for item {item_id} during balance update")
            
            logger.info(f"Successfully fetched {transactions_created} new transactions for item {item_id}")
            return Response({
                'success': True,
                'message': f'Successfully fetched transactions. {transactions_created} new transactions.',
                'transactions_count': transactions_created
            })
            
        except PlaidItem.DoesNotExist:
            logger.warning(f"Item {item_id} not found or does not belong to user {request.user.id}")
            return Response(
                {'error': 'Plaid item not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            # Log the error
            logger.error(f"Error fetching transactions for item {item_id}: {str(e)}")
            return Response(
                {'error': 'An error occurred while fetching transactions'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class TransactionsView(APIView):
    """
    List transactions for the authenticated user with filtering options
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        logger.info(f"User {request.user.id} ({request.user.username}) is requesting transactions")

        # Get query parameters for filtering
        account_id = request.query_params.get('account_id')
        start_date = request.query_params.get('start_date')
        end_date = request.query_params.get('end_date')
        category = request.query_params.get('category')
        amount_min = request.query_params.get('amount_min')
        amount_max = request.query_params.get('amount_max')

        # Log the filters being applied
        logger.info(f"Filters: account_id={account_id}, ...")
        
        # Base queryset - all transactions from user's accounts (use direct user_id comparison)
        transactions = Transaction.objects.filter(
            account__plaid_item__user_id=request.user.id
        )
        
        # Apply filters if provided
        if account_id:
            transactions = transactions.filter(account__account_id=account_id)
        
        if start_date:
            transactions = transactions.filter(date__gte=start_date)
        
        if end_date:
            transactions = transactions.filter(date__lte=end_date)
        
        if category:
            transactions = transactions.filter(category__icontains=category)
        
        if amount_min:
            transactions = transactions.filter(amount__gte=float(amount_min))
        
        if amount_max:
            transactions = transactions.filter(amount__lte=float(amount_max))
        
        # Log the result
        logger.info(f"Found {transactions.count()} transactions for user {request.user.id}")

        # Paginate results
        paginator = PageNumberPagination()
        paginator.page_size = 25  # Adjust as needed
        paginated_transactions = paginator.paginate_queryset(transactions, request)
        
        serializer = TransactionSerializer(paginated_transactions, many=True)
        return paginator.get_paginated_response(serializer.data)
    
class CategoryListCreateView(APIView):
    """
    List all categories or create a new category
    """
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        # Get system categories and user's custom categories
        categories = Category.objects.filter(
            models.Q(user=request.user) | models.Q(user__isnull=True)
        )
        serializer = CategorySerializer(categories, many=True)
        return Response(serializer.data)
    
    def post(self, request):
        # Create a new custom category for the user
        serializer = CategorySerializer(data=request.data)
        if serializer.is_valid():
            category = serializer.save(user=request.user, is_custom=True)
            return Response(CategorySerializer(category).data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class CategoryDetailView(APIView):
    """
    Retrieve, update or delete a category
    """
    permission_classes = [IsAuthenticated]
    
    def get_object(self, pk, user):
        try:
            # Can only access system categories or own custom categories
            return Category.objects.get(
                models.Q(id=pk),
                models.Q(user=user) | models.Q(user__isnull=True)
            )
        except Category.DoesNotExist:
            raise Http404
    
    def get(self, request, pk):
        category = self.get_object(pk, request.user)
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    
    def put(self, request, pk):
        category = self.get_object(pk, request.user)
        
        # Only allow updates to custom categories owned by the user
        if not category.is_custom or category.user != request.user:
            return Response(
                {"error": "Cannot modify system categories or categories owned by other users"}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        serializer = CategorySerializer(category, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    def delete(self, request, pk):
        category = self.get_object(pk, request.user)
        
        # Only allow deletion of custom categories owned by the user
        if not category.is_custom or category.user != request.user:
            return Response(
                {"error": "Cannot delete system categories or categories owned by other users"}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        category.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

Here is finance/serializers.py:
from rest_framework import serializers
from .models import PlaidItem, Account, Transaction, Category

class PlaidItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = PlaidItem
        fields = ['id', 'institution_name', 'is_active', 'created_at']
        read_only_fields = ['id', 'created_at']

class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = ['id', 'name', 'official_name', 'account_type', 'account_subtype', 
                 'current_balance', 'available_balance', 'mask', 'created_at']
        read_only_fields = ['id', 'created_at']

class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ['id', 'name', 'plaid_category_id', 'parent_category', 'is_custom', 'budget_amount']
        read_only_fields = ['id']

class TransactionSerializer(serializers.ModelSerializer):
    account_name = serializers.CharField(source='account.name', read_only=True)
    
    class Meta:
        model = Transaction
        fields = [
            'id', 'transaction_id', 'date', 'name', 'amount', 'category',
            'pending', 'payment_channel', 'merchant_name', 'account_name'
        ]
        read_only_fields = ['id', 'transaction_id']

Here is frontend/src/services/api.js:
// src/services/api.js
import axios from 'axios';

const getCsrfToken = () => {
  // Try to get CSRF token from cookie
  const name = 'csrftoken=';
  const decodedCookie = decodeURIComponent(document.cookie);
  const cookieArray = decodedCookie.split(';');
  
  for (let i = 0; i < cookieArray.length; i++) {
    let cookie = cookieArray[i].trim();
    if (cookie.indexOf(name) === 0) {
      return cookie.substring(name.length, cookie.length);
    }
  }
  return '';
};

const api = axios.create({
  baseURL: '/api',
  withCredentials: true,  // Important for sending cookies with requests
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for auth and CSRF
api.interceptors.request.use(
  (config) => {
    // Add auth token if available
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    
    // Add CSRF token for non-GET requests
    if (config.method !== 'get') {
      const csrfToken = getCsrfToken();
      if (csrfToken) {
        config.headers['X-CSRFToken'] = csrfToken;
      }
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

export default api;

Here is frontend/src/services/plaid.js:
import api from './api';

/**
 * Service for handling Plaid-related API calls
 */
const plaidService = {
  /**
   * Get a link token to initialize Plaid Link
   * @returns {Promise} Promise with the link token
   */
  getLinkToken: async () => {
    try {
      const response = await api.get('/finance/link-token/');
      return response.data;
    } catch (error) {
      console.error('Error getting link token:', error);
      throw error;
    }
  },

  /**
   * Exchange a public token for an access token
   * @param {string} publicToken - The public token from Plaid Link
   * @param {string} institutionId - The ID of the financial institution
   * @param {string} institutionName - The name of the financial institution
   * @returns {Promise} Promise with the exchange response
   */
  exchangePublicToken: async (publicToken, institutionId, institutionName) => {
    try {
      const response = await api.post('/finance/exchange-token/', {
        public_token: publicToken,
        institution_id: institutionId,
        institution_name: institutionName
      });
      return response.data;
    } catch (error) {
      console.error('Error exchanging public token:', error);
      throw error;
    }
  },

  /**
   * Get all Plaid items (connected institutions) for the current user
   * @returns {Promise} Promise with the Plaid items
   */
  getPlaidItems: async () => {
    try {
      const response = await api.get('/finance/plaid-items/');
      return response.data;
    } catch (error) {
      console.error('Error getting Plaid items:', error);
      throw error;
    }
  },

  /**
   * Get all accounts for the current user
   * @returns {Promise} Promise with the accounts
   */
  getAccounts: async () => {
    try {
      const response = await api.get('/finance/accounts/');
      return response.data;
    } catch (error) {
      console.error('Error getting accounts:', error);
      throw error;
    }
  },

  /**
   * Fetch transactions for a specific Plaid item
   * @param {string} itemId - The ID of the Plaid item
   * @returns {Promise} Promise with the fetch response
   */
  fetchTransactions: async (itemId) => {
    try {
      const response = await api.post('/finance/fetch-transactions/', {
        item_id: itemId
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching transactions:', error);
      throw error;
    }
  },

  /**
   * Get transactions with optional filtering
   * @param {Object} filters - Optional filters (account_id, start_date, end_date, etc.)
   * @returns {Promise} Promise with the transactions
   */
  getTransactions: async (filters = {}) => {
    try {
      // Convert filters object to query string parameters
      const params = new URLSearchParams();
      Object.keys(filters).forEach(key => {
        if (filters[key] !== null && filters[key] !== undefined) {
          params.append(key, filters[key]);
        }
      });

      const response = await api.get(`/finance/transactions/?${params.toString()}`);
      return response.data;
    } catch (error) {
      console.error('Error getting transactions:', error);
      throw error;
    }
  }
};

export default plaidService;